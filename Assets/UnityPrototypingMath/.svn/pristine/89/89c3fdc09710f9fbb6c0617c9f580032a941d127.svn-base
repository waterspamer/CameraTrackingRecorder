// This file is autogenerated. Edit MatrixMxN.tt instead.
namespace AntilatencyMath {
    using number = System.Single;
    using numberM = float2;
    using numberN = float2;
    using numberD = float2;
    using numberMxN = float2x2;
    using numberNxM = float2x2;

#if UNITY_5_3_OR_NEWER
    [System.Serializable]
#endif
    public partial struct float2x2 {

        public numberN row0, row1;

        public float2x2(
                number val00,
                number val01,
                number val10,
                number val11) {

            row0.x = val00;
            row0.y = val01;
            row1.x = val10;
            row1.y = val11;
        }

        private float2x2(number val) {
            row0.x = val;
            row0.y = val;
            row1.x = val;
            row1.y = val;
        }

        public float2x2(numberN row0, numberN row1) {
            this.row0 = row0;
            this.row1 = row1;
        }

        public static numberMxN withRows(numberN row0, numberN row1) {
            return new numberMxN(row0, row1);
        }

        public static numberMxN withCols(numberM col0, numberM col1) {
            return new numberMxN(
                col0.x,
                col1.x,
                col0.y,
                col1.y
            );
        }

        public static numberMxN diagonal(numberD v) {
            var result = new numberMxN();
            result.row0.x = v.x;
            result.row1.y = v.y;
        
            return result;
        }

        public static numberMxN diagonal(number v) {
            var result = new numberMxN();
            result.row0.x = v;
            result.row1.y = v;
        
            return result;
        }

        public static numberMxN filled(number val) {
            return new numberMxN(val);
        }

        public static readonly numberMxN zero = new numberMxN();

        public static readonly numberMxN ones = numberMxN.filled(1);

        public static readonly numberMxN identity = numberMxN.diagonal(1);

        public numberN row(int iRow) {
            CheckRowIndex(iRow);
            switch (iRow) {
                default:
                case 0: return row0;
                case 1: return row1;
            }
        }

        public numberM col(int iCol) {
            CheckColIndex(iCol);
            switch (iCol) {
                default:
                case 0: return new numberM(row0.x, row1.x);
                case 1: return new numberM(row0.y, row1.y);
            }
        }

        public void setRow(int iRow, numberN v) {
            CheckRowIndex(iRow);
            switch (iRow) {
                case 0: row0 = v; return;
                case 1: row1 = v; return;
            }
        }

        public void setCol(int iCol, numberM v) {
            CheckColIndex(iCol);
            switch (iCol) {
                case 0: row0.x = v.x;
                row1.x = v.y; break;
                case 1: row0.y = v.x;
                row1.y = v.y; break;
            }
        }

        public number this[int iRow, int iCol] { 
            get {
                CheckRowIndex(iRow);
                CheckColIndex(iCol);
                var idx = 2 * iRow + iCol;
                switch (idx) {
                    default:
                    case 0: return row0.x;
                    case 1: return row0.y;
                    case 2: return row1.x;
                    case 3: return row1.y;
                }
            }

            set {
                CheckRowIndex(iRow);
                CheckColIndex(iCol);
                var idx = 2 * iRow + iCol;
                switch (idx) {
                    default:
                    case 0: row0.x = value; break;
                    case 1: row0.y = value; break;
                    case 2: row1.x = value; break;
                    case 3: row1.y = value; break;
                }
            }
        }

        public double2x2 toDouble2x2() {
            return new double2x2(row0.toDouble2(), row1.toDouble2());
        }

        public static numberMxN operator - (numberMxN a) {
            return new numberMxN(-a.row0, -a.row1);
        }

        public static numberMxN operator + (numberMxN a, numberMxN b) {
            return new numberMxN(a.row0 + b.row0, a.row1 + b.row1);
        }

        public static numberMxN operator - (numberMxN a, numberMxN b) {
            return new numberMxN(a.row0 - b.row0, a.row1 - b.row1);
        }

        public static numberMxN operator * (number a, numberMxN b) {
            return new numberMxN(a * b.row0, a * b.row1);
        }

        public static numberMxN operator * (numberMxN a, number b) {
            return new numberMxN(a.row0 * b, a.row1 * b);
        }

        public static numberMxN operator / (numberMxN a, number b) {
            return new numberMxN(a.row0 / b, a.row1 / b);
        }

        public static numberM operator * (numberMxN a, numberN b) {
            return new numberM(Mathx.dot(a.row0, b), Mathx.dot(a.row1, b));
        }

        public static numberN operator * (numberM a, numberMxN b) {
            numberN result = new numberN();
            result += a.x * b.row0;
            result += a.y * b.row1;

            return result;
        }

        public static float2x2 operator * (numberMxN a, float2x2 b) {
            var result = float2x2.zero;
            for (int i = 0; i < 2; i++)
            for (int j = 0; j < 2; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

        public static float2x3 operator * (numberMxN a, float2x3 b) {
            var result = float2x3.zero;
            for (int i = 0; i < 2; i++)
            for (int j = 0; j < 3; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

        public static float2x4 operator * (numberMxN a, float2x4 b) {
            var result = float2x4.zero;
            for (int i = 0; i < 2; i++)
            for (int j = 0; j < 4; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

        public numberNxM transpose() {
            var result = new numberNxM();
            for (int i = 0; i < 2; i++)
            for (int j = 0; j < 2; j++)
                result[j, i] = this[i, j];

            return result;
        }

        private static void CheckRowIndex(int iRow) {
            if (iRow < 0 || iRow >= 2)
                throw new System.IndexOutOfRangeException("Matrix index is out of bounds");
        }

        private static void CheckColIndex(int iCol) {
            if (iCol < 0 || iCol > 2)
                throw new System.IndexOutOfRangeException("Matrix index is out of bounds");
        }
    }
}
