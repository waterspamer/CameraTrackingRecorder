// This file is autogenerated. Edit Mathx_ArrayMatrix.tt instead.
namespace AntilatencyMath {

    using T = System.Double;

    public static partial class Mathx {

        public static int numRows(this T[,] matrix) {
            return matrix.GetLength(0);
        }

        public static int numCols(this T[,] matrix) {
            return matrix.GetLength(1);
        }

        public static T[] row(this T[,] matrix, int i) {
            var numRows = matrix.numRows();
            if (i < 0 || i >= numRows)
                throw new System.ArgumentOutOfRangeException("i", "row index is out of range");

            var nCols = matrix.numCols();
            var result = new T[nCols];
            for (int j = 0; j < nCols; j++)
                result[j] = matrix[i, j];

            return result;
        }

        public static T[] col(this T[,] matrix, int j) {
            var nCols = matrix.numCols();
            if (j < 0 || j >= nCols)
                throw new System.ArgumentOutOfRangeException("j", "column index is out of range");

            var nRows = matrix.numRows();
            var result = new T[nRows];
            for (int i = 0; i < nRows; i++)
                result[i] = matrix[i, j];

            return result;
        }

        public static void setRow(this T[,] matrix, int i, T[] value) {
            var nRows = matrix.numRows();
            if (i < 0 || i >= nRows)
                throw new System.ArgumentOutOfRangeException("i", "row index is out of range");

            var nCols = matrix.numCols();
            for (int j = 0; j < nCols; j++)
                matrix[i, j] = value[j];
        }

        public static void setCol(this T[,] matrix, int j, T[] value) {
            var nCols = matrix.numCols();
            if (j < 0 || j >= nCols)
                throw new System.ArgumentOutOfRangeException("j", "column index is out of range");

            var nRows = matrix.numRows();
            for (int i = 0; i < nRows; i++)
                matrix[i, j] = value[i];
        }

        public static T[,] selectRowsCols(this T[,] matrix, int[] rows, int[] cols) {
            var result = new T[rows.Length, cols.Length];
            for (int i = 0; i < rows.Length; i++) {
                for (int j = 0; j < cols.Length; j++)
                    result[i, j] = matrix[rows[i], cols[j]];
            }

            return result;
        }

        public static T trace(T[,] matrix) {
            int nRows = Mathx.numRows(matrix);
            int nCols = Mathx.numCols(matrix);
            int n = System.Math.Min(nRows, nCols);

            T result = 0;
            for (int i = 0; i < n; i++)
                result += matrix[i, i];

            return result;
        }

        public static T maxAbs(T[,] matrix) {
            int nRows = Mathx.numRows(matrix);
            int nCols = Mathx.numCols(matrix);

            T maxAbs = 0;
            for (int i = 0; i < nRows; i++) {
                for (int j = 0; j < nCols; j++) {
                    var abs = System.Math.Abs(matrix[i, j]);
                    if (abs > maxAbs)
                        maxAbs = abs;
                }
            }

            return maxAbs;
        }

        public static T[,] abs(T[,] m) {
            int nRows = m.GetLength(0);
            int nCols = m.GetLength(1);
            var result = new T[nRows, nCols];
            for (int i = 0; i < result.Length; i++) {
                for (int j = 0; j < result.Length; j++)
                    result[i, j] = (T)System.Math.Abs(m[i, j]);
            }

            return result;
        }

        public static T[,] sqr(T[,] m) {
            int nRows = m.GetLength(0);
            int nCols = m.GetLength(1);
            var result = new T[nRows, nCols];
            for (int i = 0; i < result.Length; i++) {
                for (int j = 0; j < result.Length; j++)
                    result[i, j] = m[i, j] * m[i, j];
            }

            return result;
        }

        public static T[,] sqrt(T[,] m) {
            int nRows = m.GetLength(0);
            int nCols = m.GetLength(1);
            var result = new T[nRows, nCols];
            for (int i = 0; i < result.Length; i++) {
                for (int j = 0; j < result.Length; j++)
                    result[i, j] = (T)System.Math.Sqrt(m[i, j]);
            }

            return result;
        }

        public static T[,] sin(T[,] m) {
            int nRows = m.GetLength(0);
            int nCols = m.GetLength(1);
            var result = new T[nRows, nCols];
            for (int i = 0; i < result.Length; i++) {
                for (int j = 0; j < result.Length; j++)
                    result[i, j] = (T)System.Math.Sin(m[i, j]);
            }

            return result;
        }

        public static T[,] cos(T[,] m) {
            int nRows = m.GetLength(0);
            int nCols = m.GetLength(1);
            var result = new T[nRows, nCols];
            for (int i = 0; i < result.Length; i++) {
                for (int j = 0; j < result.Length; j++)
                    result[i, j] = (T)System.Math.Cos(m[i, j]);
            }

            return result;
        }

        public static T[,] tan(T[,] m) {
            int nRows = m.GetLength(0);
            int nCols = m.GetLength(1);
            var result = new T[nRows, nCols];
            for (int i = 0; i < result.Length; i++) {
                for (int j = 0; j < result.Length; j++)
                    result[i, j] = (T)System.Math.Tan(m[i, j]);
            }

            return result;
        }


        public static T[,] plus(T[,] a, T[,] b) {
            int aNumRows = a.numRows();
            int aNumCols = a.numCols();
            int bNumRows = b.numRows();
            int bNumCols = b.numCols();
            if (aNumRows != bNumRows || aNumCols != bNumCols)
                throw new System.ArgumentException("matrix operands dimensions do not match");

            var result = new T[aNumRows, aNumCols];
            for (int i = 0; i < aNumRows; i++) {
                for (int j = 0; j < aNumCols; j++)
                    result[i, j] = a[i, j] + b[i, j];
            }

            return result;
        }

        public static T[,] minus(T[,] a, T[,] b) {
            int aNumRows = a.numRows();
            int aNumCols = a.numCols();
            int bNumRows = b.numRows();
            int bNumCols = b.numCols();
            if (aNumRows != bNumRows || aNumCols != bNumCols)
                throw new System.ArgumentException("matrix operands dimensions do not match");

            var result = new T[aNumRows, aNumCols];
            for (int i = 0; i < aNumRows; i++) {
                for (int j = 0; j < aNumCols; j++)
                    result[i, j] = a[i, j] - b[i, j];
            }

            return result;
        }

        public static T[,] atan2(T[,] a, T[,] b) {
            int aNumRows = a.numRows();
            int aNumCols = a.numCols();
            int bNumRows = b.numRows();
            int bNumCols = b.numCols();
            if (aNumRows != bNumRows || aNumCols != bNumCols)
                throw new System.ArgumentException("matrix operands dimensions do not match");

            var result = new T[aNumRows, aNumCols];
            for (int i = 0; i < aNumRows; i++) {
                for (int j = 0; j < aNumCols; j++)
                    result[i, j] = (T)System.Math.Atan2(a[i, j], b[i, j]);
            }

            return result;
        }


        public static T[,] mul(T[,] a, T[,] b) {
            int aNumRows = a.numRows();
            int aNumCols = a.numCols();
            int bNumRows = b.numRows();
            int bNumCols = b.numCols();

            if (aNumCols != bNumRows)
                throw new System.ArgumentException("invalid matrix operands dimensions");

            var result = new T[aNumRows, bNumCols];
            for (int i = 0; i < aNumRows; i++) {

                for (int j = 0; j < bNumCols; j++) {
                    T sum = 0;
                    for (int k = 0; k < aNumCols; k++)
                        sum += a[i, k] * b[k, j];

                    result[i, j] = sum;
                }
            }

            return result;
        }

        public static T[] mul(T[,] a, T[] b) {
            int aNumRows = a.numRows();
            int aNumCols = a.numCols();

            if (aNumCols != b.Length)
                throw new System.ArgumentException("invalid matrix operands dimensions");

            var result = new T[aNumRows];
            for (int i = 0; i < aNumRows; i++) {

                T sum = 0;
                for (int k = 0; k < aNumCols; k++)
                    sum += a[i, k] * b[k];

                result[i] = sum;
            }

            return result;
        }
    }
}
