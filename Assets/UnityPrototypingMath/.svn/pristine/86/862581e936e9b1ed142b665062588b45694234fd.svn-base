// This file is autogenerated. Edit MatrixMxN.tt instead.
namespace AntilatencyMath {
    using number = System.Single;
    using numberM = float3;
    using numberN = float3;
    using numberD = float3;
    using numberMxN = float3x3;
    using numberNxM = float3x3;

#if UNITY_5_3_OR_NEWER
    [System.Serializable]
#endif
    public partial struct float3x3 {

        public numberN row0, row1, row2;

        public float3x3(
                number val00,
                number val01,
                number val02,
                number val10,
                number val11,
                number val12,
                number val20,
                number val21,
                number val22) {

            row0.x = val00;
            row0.y = val01;
            row0.z = val02;
            row1.x = val10;
            row1.y = val11;
            row1.z = val12;
            row2.x = val20;
            row2.y = val21;
            row2.z = val22;
        }

        private float3x3(number val) {
            row0.x = val;
            row0.y = val;
            row0.z = val;
            row1.x = val;
            row1.y = val;
            row1.z = val;
            row2.x = val;
            row2.y = val;
            row2.z = val;
        }

        public float3x3(numberN row0, numberN row1, numberN row2) {
            this.row0 = row0;
            this.row1 = row1;
            this.row2 = row2;
        }

        public static numberMxN withRows(numberN row0, numberN row1, numberN row2) {
            return new numberMxN(row0, row1, row2);
        }

        public static numberMxN withCols(numberM col0, numberM col1, numberM col2) {
            return new numberMxN(
                col0.x,
                col1.x,
                col2.x,
                col0.y,
                col1.y,
                col2.y,
                col0.z,
                col1.z,
                col2.z
            );
        }

        public static numberMxN diagonal(numberD v) {
            var result = new numberMxN();
            result.row0.x = v.x;
            result.row1.y = v.y;
            result.row2.z = v.z;
        
            return result;
        }

        public static numberMxN diagonal(number v) {
            var result = new numberMxN();
            result.row0.x = v;
            result.row1.y = v;
            result.row2.z = v;
        
            return result;
        }

        public static numberMxN filled(number val) {
            return new numberMxN(val);
        }

        public static readonly numberMxN zero = new numberMxN();

        public static readonly numberMxN ones = numberMxN.filled(1);

        public static readonly numberMxN identity = numberMxN.diagonal(1);

        public numberN row(int iRow) {
            CheckRowIndex(iRow);
            switch (iRow) {
                default:
                case 0: return row0;
                case 1: return row1;
                case 2: return row2;
            }
        }

        public numberM col(int iCol) {
            CheckColIndex(iCol);
            switch (iCol) {
                default:
                case 0: return new numberM(row0.x, row1.x, row2.x);
                case 1: return new numberM(row0.y, row1.y, row2.y);
                case 2: return new numberM(row0.z, row1.z, row2.z);
            }
        }

        public void setRow(int iRow, numberN v) {
            CheckRowIndex(iRow);
            switch (iRow) {
                case 0: row0 = v; return;
                case 1: row1 = v; return;
                case 2: row2 = v; return;
            }
        }

        public void setCol(int iCol, numberM v) {
            CheckColIndex(iCol);
            switch (iCol) {
                case 0: row0.x = v.x;
                row1.x = v.y;
                row2.x = v.z; break;
                case 1: row0.y = v.x;
                row1.y = v.y;
                row2.y = v.z; break;
                case 2: row0.z = v.x;
                row1.z = v.y;
                row2.z = v.z; break;
            }
        }

        public number this[int iRow, int iCol] { 
            get {
                CheckRowIndex(iRow);
                CheckColIndex(iCol);
                var idx = 3 * iRow + iCol;
                switch (idx) {
                    default:
                    case 0: return row0.x;
                    case 1: return row0.y;
                    case 2: return row0.z;
                    case 3: return row1.x;
                    case 4: return row1.y;
                    case 5: return row1.z;
                    case 6: return row2.x;
                    case 7: return row2.y;
                    case 8: return row2.z;
                }
            }

            set {
                CheckRowIndex(iRow);
                CheckColIndex(iCol);
                var idx = 3 * iRow + iCol;
                switch (idx) {
                    default:
                    case 0: row0.x = value; break;
                    case 1: row0.y = value; break;
                    case 2: row0.z = value; break;
                    case 3: row1.x = value; break;
                    case 4: row1.y = value; break;
                    case 5: row1.z = value; break;
                    case 6: row2.x = value; break;
                    case 7: row2.y = value; break;
                    case 8: row2.z = value; break;
                }
            }
        }

        public double3x3 toDouble3x3() {
            return new double3x3(row0.toDouble3(), row1.toDouble3(), row2.toDouble3());
        }

        public static numberMxN operator - (numberMxN a) {
            return new numberMxN(-a.row0, -a.row1, -a.row2);
        }

        public static numberMxN operator + (numberMxN a, numberMxN b) {
            return new numberMxN(a.row0 + b.row0, a.row1 + b.row1, a.row2 + b.row2);
        }

        public static numberMxN operator - (numberMxN a, numberMxN b) {
            return new numberMxN(a.row0 - b.row0, a.row1 - b.row1, a.row2 - b.row2);
        }

        public static numberMxN operator * (number a, numberMxN b) {
            return new numberMxN(a * b.row0, a * b.row1, a * b.row2);
        }

        public static numberMxN operator * (numberMxN a, number b) {
            return new numberMxN(a.row0 * b, a.row1 * b, a.row2 * b);
        }

        public static numberMxN operator / (numberMxN a, number b) {
            return new numberMxN(a.row0 / b, a.row1 / b, a.row2 / b);
        }

        public static numberM operator * (numberMxN a, numberN b) {
            return new numberM(Mathx.dot(a.row0, b), Mathx.dot(a.row1, b), Mathx.dot(a.row2, b));
        }

        public static numberN operator * (numberM a, numberMxN b) {
            numberN result = new numberN();
            result += a.x * b.row0;
            result += a.y * b.row1;
            result += a.z * b.row2;

            return result;
        }

        public static float3x2 operator * (numberMxN a, float3x2 b) {
            var result = float3x2.zero;
            for (int i = 0; i < 3; i++)
            for (int j = 0; j < 2; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

        public static float3x3 operator * (numberMxN a, float3x3 b) {
            var result = float3x3.zero;
            for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

        public static float3x4 operator * (numberMxN a, float3x4 b) {
            var result = float3x4.zero;
            for (int i = 0; i < 3; i++)
            for (int j = 0; j < 4; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

        public numberMxN inverse() {
            var result = new numberMxN();
            result[0, 0] =  (this[1, 1]*this[2, 2] - this[1, 2]*this[2, 1])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[0, 1] = -(this[0, 1]*this[2, 2] - this[0, 2]*this[2, 1])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[0, 2] =  (this[0, 1]*this[1, 2] - this[0, 2]*this[1, 1])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[1, 0] = -(this[1, 0]*this[2, 2] - this[1, 2]*this[2, 0])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[1, 1] =  (this[0, 0]*this[2, 2] - this[0, 2]*this[2, 0])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[1, 2] = -(this[0, 0]*this[1, 2] - this[0, 2]*this[1, 0])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[2, 0] =  (this[1, 0]*this[2, 1] - this[1, 1]*this[2, 0])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[2, 1] = -(this[0, 0]*this[2, 1] - this[0, 1]*this[2, 0])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[2, 2] =  (this[0, 0]*this[1, 1] - this[0, 1]*this[1, 0])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);

            return result;
        }

        public numberNxM transpose() {
            var result = new numberNxM();
            for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
                result[j, i] = this[i, j];

            return result;
        }

        private static void CheckRowIndex(int iRow) {
            if (iRow < 0 || iRow >= 3)
                throw new System.IndexOutOfRangeException("Matrix index is out of bounds");
        }

        private static void CheckColIndex(int iCol) {
            if (iCol < 0 || iCol > 3)
                throw new System.IndexOutOfRangeException("Matrix index is out of bounds");
        }
    }
}
