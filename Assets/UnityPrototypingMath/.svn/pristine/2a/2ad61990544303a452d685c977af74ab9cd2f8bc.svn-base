// This file is autogenerated. Edit Mathx.tt instead.
namespace AntilatencyMath {

    using System;
    using System.Collections.Generic;
    using T = System.Single;

    public static partial class Mathx {

        public static T min(T a, T b) {
            return System.Math.Min(a, b);
        }

        public static T max(T a, T b) {
            return System.Math.Max(a, b);
        }

        public static T clamp(T x, T min, T max) {
            if (x < min)
                return min;

            if (x > max)
                return max;

            return x;
        }

        public static T sum(IEnumerable<T> xs) {
            T result = 0;
            foreach (var x in xs)
                result += x;

            return result;
        }

        public static T product(IEnumerable<T> xs) {
            T result = 1;
            foreach (var x in xs)
                result *= x;

            return result;
        }

        public static T horner(T x, T[] coefficients) {

            if (coefficients.Length == 0)
                throw new System.ArgumentException("coefficients: must be non-empty");

            T result = coefficients[coefficients.Length-1];
            for (int i = coefficients.Length - 2; i >= 0; i--) {
                result = result * x + coefficients[i];
            }

            return result;
        }

        public static T lerp(T a, T b, T t) {
            return (1 - t) * a + t * b;
        }

        public static T polylineInterpolate(T[] knots, T tau) {

            if (knots == null)
                throw new ArgumentNullException("knots");

            if (knots.Length == 0)
                throw new ArgumentOutOfRangeException("knots");

            T scaledTau = tau * (knots.Length - 1);
            int i = (int)scaledTau;
            T e = scaledTau % 1;

            if (i == knots.Length - 1) {
                i = knots.Length - 2;
                e = 1;
            }

            return Mathx.lerp(knots[i], knots[i + 1], e);
        }

        public static IEnumerable<T> linspace(T a, T b, int num) {

            if (num <= 1)
                yield break;

            for (int i = 0; i < num; i++) {
                T t = (T)i / (num - 1);
                yield return lerp(a, b, t);
            }
        }
    }
}
