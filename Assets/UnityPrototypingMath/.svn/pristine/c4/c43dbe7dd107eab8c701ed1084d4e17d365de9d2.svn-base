<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".dummy" #>
<#@ include file="TemplateHelpers/T4MultipleOutputs.ttinclude" #>
<#@ include file="TemplateHelpers/T4AnonymousList.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
    System.Func<
        System.Func<string, string>,
        System.Func<string, string>
    > Id1 = x => x;

    System.Func<
        System.Func<string, string, string>,
        System.Func<string, string, string>
    > Id2 = x => x;

    var numberTypes = CreateList(
        new { shortName="float",  qualifiedName="System.Single" },
        new { shortName="double", qualifiedName="System.Double" }
    );

    var unaryElementwiseFunctions = CreateList(
        new { name = "abs",  apply = Id1(x => $"(T)System.Math.Abs({x})") },
        new { name = "sqr",  apply = Id1(x => $"{x} * {x}") },
        new { name = "sqrt", apply = Id1(x => $"(T)System.Math.Sqrt({x})") },
        new { name = "exp",  apply = Id1(x => $"(T)System.Math.Exp({x})") },
        new { name = "log",  apply = Id1(x => $"(T)System.Math.Log({x})") },
        new { name = "sin",  apply = Id1(x => $"(T)System.Math.Sin({x})") },
        new { name = "cos",  apply = Id1(x => $"(T)System.Math.Cos({x})") },
        new { name = "tan",  apply = Id1(x => $"(T)System.Math.Tan({x})") }
    );

    var binaryElementwiseFunctions = CreateList(
        new { name="plus",  apply = Id2((a, b) => $"{a} + {b}") },
        new { name="minus", apply = Id2((a, b) => $"{a} - {b}") },
        new { name="atan2", apply = Id2((a, b) => $"(T)System.Math.Atan2({a}, {b})") },
        new { name="pow",   apply = Id2((a, b) => $"(T)System.Math.Pow({a}, {b})") }
    );

    var variants =
        from numType in numberTypes
        select new {
            outputName = $"Mathx_ScalarFunctions_{numType.shortName}",
            numberType = numType
        };

    MultipleOutputs.OutputExtension = ".cs";
    MultipleOutputs.OutputDirectory = "Src/Generated";

    MultipleOutputs.ForEachVariant(this.GenerationEnvironment, variants, v => {
#>
// This file is autogenerated. Edit Mathx_ScalarFunctions.tt instead.
namespace AntilatencyMath {

    using T = <#= v.numberType.qualifiedName #>;

    public static partial class Mathx {

<# foreach (var f in unaryElementwiseFunctions) { #>
        public static T <#= f.name #>(T x) {
            return <#= f.apply("x") #>;
        }

<# } #>

<# foreach (var f in binaryElementwiseFunctions) { #>
        public static T <#= f.name #>(T a, T b) {
            return <#= f.apply("a", "b") #>;
        }

<# } #>
    }
}
<# }); #>
