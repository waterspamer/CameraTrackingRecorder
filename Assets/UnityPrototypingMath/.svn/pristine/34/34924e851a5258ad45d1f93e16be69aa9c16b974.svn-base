<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".dummy" #>
<#@ include file="TemplateHelpers/T4MultipleOutputs.ttinclude" #>
<#@ include file="TemplateHelpers/T4AnonymousList.ttinclude" #>
<#@ include file="TemplateHelpers/T4GenShortcuts.ttinclude" #>
<#@ include file="TemplateHelpers/T4StringUtils.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
    var numberTypes = CreateList(
        new { shortName="float",  qualifiedName="System.Single" },
        new { shortName="double", qualifiedName="System.Double" }
    );

    var variants =
        from numType in numberTypes
        select new {
            outputName = $"{numType.shortName}P3Q",
            numberType = numType,
        };

    MultipleOutputs.OutputExtension = ".cs";
    MultipleOutputs.OutputDirectory = "Src/Generated";

    MultipleOutputs.ForEachVariant(this.GenerationEnvironment, variants, v => {
#>
// This file is autogenerated. Edit Quaternion.tt instead.
namespace AntilatencyMath {
    using System;

    using number = <#= v.numberType.qualifiedName #>;
    using number3 = <#= v.numberType.shortName + "3" #>;
    using numberQ = <#= v.numberType.shortName + "Q" #>;
    using numberP3Q = <#= v.outputName #>;

    #if UNITY_5_3_OR_NEWER
    [System.Serializable]
    #endif
    public partial struct <#= v.outputName #> {

        public number3 position;
        public numberQ rotation;

        public <#= v.outputName #>(number3 position, numberQ rotation) {
            this.position = position;
            this.rotation = rotation;
        }

        public <#= v.outputName #>(number3 position) {
            this.position = position;
            this.rotation = numberQ.identity;
        }

        public <#= v.outputName #>(numberQ rotation) {
            this.position = number3.zero;
            this.rotation = rotation;
        }

        public numberP3Q conjugate {
            get {
                var conjRotation = rotation.conjugate;
                return new numberP3Q(-(conjRotation * position), conjRotation);
            }
        }

        public numberP3Q inverse {
            get {
                var invRotation = rotation.inverse;
                return new numberP3Q(-(invRotation * position), invRotation);
            }
        }

        public static numberP3Q zero {
            get { return new numberP3Q(number3.zero, numberQ.zero); }
        }

        public static numberP3Q identity {
            get { return new numberP3Q(number3.zero, numberQ.identity); }
        }

        public static numberP3Q operator * (numberP3Q a, numberP3Q b) {
            return new numberP3Q(
                a.position + a.rotation * b.position,
                a.rotation * b.rotation
            );
        }

        public static number3 operator * (numberP3Q p, number3 v) {
            return p.position + p.rotation * v;
        }
    }
}
<# }); #>
