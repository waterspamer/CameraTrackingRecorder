<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".dummy" #>
<#@ include file="TemplateHelpers/T4MultipleOutputs.ttinclude" #>
<#@ include file="TemplateHelpers/T4AnonymousList.ttinclude" #>
<#@ include file="TemplateHelpers/T4GenShortcuts.ttinclude" #>
<#@ include file="TemplateHelpers/T4StringUtils.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
    var components = "xyzw".ToArray();
    var numberTypes = CreateList(
        new { shortName="float",  qualifiedName="System.Single" },
        new { shortName="double", qualifiedName="System.Double" }
    );

    var variants =
        from numType in numberTypes
        select new {
            outputName = $"{numType.shortName}Q",
            numberType = numType,
        };

    MultipleOutputs.OutputExtension = ".cs";
    MultipleOutputs.OutputDirectory = "Src/Generated";

    MultipleOutputs.ForEachVariant(this.GenerationEnvironment, variants, v => {
#>
// This file is autogenerated. Edit Quaternion.tt instead.
namespace AntilatencyMath {
    using System;

    using number = <#= v.numberType.qualifiedName #>;
    using number3 = <#= v.numberType.shortName + "3" #>;
    using number4 = <#= v.numberType.shortName + "4" #>;
    using number3x3 = <#= v.numberType.shortName + "3x3" #>;
    using numberQ = <#= v.outputName #>;

    #if UNITY_5_3_OR_NEWER
    [System.Serializable]
    #endif
    public partial struct <#= v.outputName #> {
        public number x, y, z, w;

        public <#= v.outputName #>(number x, number y, number z, number w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        public <#= v.outputName #>(number3 v, number w) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = w;
        }

        public number3 vector {
            get { return new number3(x, y, z); }
        }

        public number sqrNorm {
            get { return x * x + y * y + z * z + w * w; }
        }

        public number norm {
            get { return (number)Math.Sqrt(sqrNorm); }
        }

        public void normalize() {
            var norm = this.norm;
            x /= norm;
            y /= norm;
            z /= norm;
            w /= norm;
        }

        public numberQ normalized {
            get { return this / norm; }
        }

        public numberQ conjugate {
            get { return new numberQ(-x, -y, -z, w); }
        }

        public numberQ inverse {
            get { return conjugate / sqrNorm; }
        }

<#
    foreach (var numberTypeP in numberTypes) {
        var vectorTypeP = numberTypeP.shortName + 4;
        var quaternionTypeP = numberTypeP.shortName + "Q";

        var conv = "";
        if (numberTypeP != v.numberType)
            conv = $"({numberTypeP.qualifiedName})";
#>
        public <#=vectorTypeP#> to<#=Capitalize(numberTypeP.shortName)#>4() {
            return new <#=vectorTypeP#>(<#=conv#>x, <#=conv#>y, <#=conv#>z, <#=conv#>w);
        }

<# if (numberTypeP != v.numberType) { #>
        public <#=quaternionTypeP#> to<#=Capitalize(numberTypeP.shortName)#>Q() {
            return new <#=quaternionTypeP#>(<#=conv#>x, <#=conv#>y, <#=conv#>z, <#=conv#>w);
        }

<# } #>
<# } #>
        public number3x3 toRotationMatrix() {
            var vcross = Mathx.crossMatrix(vector);
            var ident  = number3x3.identity;
            return ident + 2 * (w * ident  + vcross) * vcross;
        }

        public number3x3 toRotationMatrixT() {
            return toRotationMatrix().transpose();
        }

        public number3 toRotationVector() {
            var imaginaryPartMagnitude = vector.magnitude;
            var scale = 4 * (number)Math.Atan2(imaginaryPartMagnitude, 1 + w) / imaginaryPartMagnitude;

            if (number.IsNaN(scale))
                return number3.zero;

            return scale * vector;
        }

		public static numberQ fromAxisAngle(number3 axis, number angle) {
			axis.normalize();
            var sinA = (number)Math.Sin(angle / 2);
            var cosA = (number)Math.Cos(angle / 2);
            return new numberQ( axis.x * sinA, axis.y * sinA, axis.z * sinA, cosA );
		}

        public static numberQ fromRotationVector(number3 v) {
            var angle = v.magnitude;
            if (angle == 0)
                return numberQ.identity;

            var sin = (number)Math.Sin(angle / 2);
            var cos = (number)Math.Cos(angle / 2);
            return new numberQ(v * sin / angle, cos);
        }

        public static numberQ zero {
            get { return new numberQ(0, 0, 0, 0); }
        }

        public static numberQ identity {
            get { return new numberQ(0, 0, 0, 1); }
        }

        public static numberQ operator ~ (numberQ q) {
            return q.conjugate;
        }

        public static numberQ operator - (numberQ q) {
            return new numberQ(-q.x, -q.y, -q.z, -q.w);
        }

        public static numberQ operator + (numberQ a, numberQ b) {
            return new numberQ(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
        }

        public static numberQ operator - (numberQ a, numberQ b) {
            return new numberQ(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
        }

        public static numberQ operator * (numberQ a, number b) {
            return new numberQ(a.x * b, a.y * b, a.z * b, a.w * b);
        }

        public static numberQ operator * (number a, numberQ b) {
            return new numberQ(a * b.x, a * b.y, a * b.z, a * b.w);
        }

        public static numberQ operator / (numberQ a, number b) {
            return new numberQ(a.x / b, a.y / b, a.z / b, a.w / b);
        }

        public static numberQ operator * (numberQ a, numberQ b) {
            return new numberQ(
                a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
                a.w * b.y + a.y * b.w + a.z * b.x - a.x * b.z,
                a.w * b.z + a.z * b.w + a.x * b.y - a.y * b.x,
                a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z);
        }

        public static numberQ operator / (numberQ a, numberQ b) {
            return a * b.inverse;
        }

        public static number3 operator * (numberQ q, number3 v) {
            number4 qv = new number4(
                q.w * v.x + q.y * v.z - q.z * v.y,
                q.w * v.y + q.z * v.x - q.x * v.z,
                q.w * v.z + q.x * v.y - q.y * v.x,
                -q.x * v.x - q.y * v.y - q.z * v.z
            );

            return new number3(
                qv.w * -q.x + qv.x * q.w + qv.y * -q.z - qv.z * -q.y,
                qv.w * -q.y + qv.y * q.w + qv.z * -q.x - qv.x * -q.z,
                qv.w * -q.z + qv.z * q.w + qv.x * -q.y - qv.y * -q.x
            );
        }

        public static numberQ lerp(numberQ a, numberQ b, number t) {
            if (t < 0) t = 0;
            if (t > 1) t = 1;
            var result = (1 - t) * a + t * b;
            result.normalize();

            return result;
        }

        public static number dot(numberQ a, numberQ b) {
            return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
        }

        public static numberQ exp(numberQ q) {
            numberQ result = q;
            exp(ref result);
            return result;
        }

        public static numberQ log(numberQ q) {
            numberQ result = q;
            log(ref result);
            return result;
        }

        public static numberQ pow(numberQ q, number n) {
            numberQ result = q;
            pow(ref result, n);
            return result;
        }

        public static void exp(ref numberQ q) {
            var r = q.vector.magnitude;
            var et = (number)Math.Exp(q.w);
            var s = r >= (number)0.00001 ? et * (number)Math.Sin(r) / r : (number)0;
            q.w = et * (number)Math.Cos(r);
            q.x *= s;
            q.y *= s;
            q.z *= s;
        }

        public static void log(ref numberQ q) {
            var r = q.vector.magnitude;
            var t = r > (number)0.00001 ? (number)Math.Atan2(r, q.w) / r : (number)0;
            q.w = (number)Math.Log(q.sqrNorm) / 2;
            q.x *= t;
            q.y *= t;
            q.z *= t;
        }

        public static void pow(ref numberQ q, number n) {
            log(ref q);
            q *= n;
            exp(ref q);
        }
    }
}
<# }); #>
