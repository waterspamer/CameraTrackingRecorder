<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".dummy" #>
<#@ include file="TemplateHelpers/T4MultipleOutputs.ttinclude" #>
<#@ include file="TemplateHelpers/T4AnonymousList.ttinclude" #>
<#@ include file="TemplateHelpers/T4GenShortcuts.ttinclude" #>
<#@ include file="TemplateHelpers/T4StringUtils.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
    var components = "xyzw".ToArray();
    var dimensions = CreateList(2, 3, 4);
    var numberTypes = CreateList(
        new { shortName="float",  qualifiedName="System.Single" },
        new { shortName="double", qualifiedName="System.Double" }
    );

    var variants =
        from numType in numberTypes
        from nRows in dimensions
        from nCols in dimensions
        select new {
            outputName = $"{numType.shortName}{nRows}x{nCols}",
            numberType = numType,
            nRows      = nRows,
            nCols      = nCols,
        };

    MultipleOutputs.OutputExtension = ".cs";
    MultipleOutputs.OutputDirectory = "Src/Generated";

    MultipleOutputs.ForEachVariant(this.GenerationEnvironment, variants, v => {
        var nDiagonal = System.Math.Min(v.nRows, v.nCols);

        Func<Func<int, string>, string> GenR = f => GenN(v.nRows, i=>f(i));
        Func<Func<int, string>, string> GenC = f => GenN(v.nCols, j=>f(j));
        Func<Func<int, string>, string> genR = f => GenN(v.nRows, i=>f(i), sep: ", ");
        Func<Func<int, string>, string> genC = f => GenN(v.nCols, j=>f(j), sep: ", ");

        Func<Func<int, int, string>, string> GenRC = f =>
                GenN(v.nRows, i=>GenN(v.nCols, j=>f(i, j)));
        Func<Func<int, int, string>, string> GenCR = f =>
                GenN(v.nCols, j=>GenN(v.nRows, i=>f(i, j)));
        Func<Func<int, int, string>, string> genRC = f =>
                GenN(v.nRows, i=>GenN(v.nCols, j=>f(i, j), sep: ", "), sep: ", ");
        Func<Func<int, int, string>, string> genCR = f =>
                GenN(v.nCols, j=>GenN(v.nRows, i=>f(i, j), sep: ", "), sep: ", ");
#>
// This file is autogenerated. Edit MatrixMxN.tt instead.
namespace AntilatencyMath {
    using number = <#= v.numberType.qualifiedName #>;
    using numberM = <#= v.numberType.shortName + v.nRows #>;
    using numberN = <#= v.numberType.shortName + v.nCols #>;
    using numberD = <#= v.numberType.shortName + nDiagonal #>;
    using numberMxN = <#= v.outputName #>;
    using numberNxM = <#= v.numberType.shortName + v.nCols + "x" + v.nRows #>;

#if UNITY_5_3_OR_NEWER
    [System.Serializable]
#endif
    public partial struct <#= v.outputName #> {

        public numberN <#= genR(i => $"row{i}") #>;

        public <#= v.outputName#>(
                <#= GenRC((i,j) => $"number val{i}{j},").TrimEnd(',') #>) {

            <#= GenRC((i,j) => $"row{i}.{components[j]} = val{i}{j};") #>
        }

        private <#= v.outputName #>(number val) {
            <#= GenRC((i,j) => $"row{i}.{components[j]} = val;") #>
        }

        public <#= v.outputName #>(<#= genR(i=>$"numberN row{i}") #>) {
            <#= GenR(i=>$"this.row{i} = row{i};") #>
        }

        public static numberMxN withRows(<#= genR(i=>$"numberN row{i}") #>) {
            return new numberMxN(<#= genR(i => $"row{i}") #>);
        }

        public static numberMxN withCols(<#= genC(j=>$"numberM col{j}") #>) {
            return new numberMxN(
                <#= GenRC((i,j)=>$"col{j}.{components[i]},").TrimEnd(',') #>
            );
        }

        public static numberMxN diagonal(numberD v) {
            var result = new numberMxN();
            <#= GenN(nDiagonal, i => $"result.row{i}.{components[i]} = v.{components[i]};") #>
        
            return result;
        }

        public static numberMxN diagonal(number v) {
            var result = new numberMxN();
            <#= GenN(nDiagonal, i => $"result.row{i}.{components[i]} = v;") #>
        
            return result;
        }

        public static numberMxN filled(number val) {
            return new numberMxN(val);
        }

        public static readonly numberMxN zero = new numberMxN();

        public static readonly numberMxN ones = numberMxN.filled(1);

        public static readonly numberMxN identity = numberMxN.diagonal(1);

        public numberN row(int iRow) {
            CheckRowIndex(iRow);
            switch (iRow) {
                default:
                <#= GenR(i => $"case {i}: return row{i};") #>
            }
        }

        public numberM col(int iCol) {
            CheckColIndex(iCol);
            switch (iCol) {
                default:
                <#= GenC(j => $"case {j}: return new numberM({genR(i => $"row{i}.{components[j]}")});") #>
            }
        }

        public void setRow(int iRow, numberN v) {
            CheckRowIndex(iRow);
            switch (iRow) {
                <#= GenR(i => $"case {i}: row{i} = v; return;") #>
            }
        }

        public void setCol(int iCol, numberM v) {
            CheckColIndex(iCol);
            switch (iCol) {
                <#= GenC(j => $"case {j}: {GenR(i => $"row{i}.{components[j]} = v.{components[i]};")} break;") #>
            }
        }

        public number this[int iRow, int iCol] { 
            get {
                CheckRowIndex(iRow);
                CheckColIndex(iCol);
                var idx = <#= v.nCols #> * iRow + iCol;
                switch (idx) {
                    default:
                    <#= GenRC((i,j) => $"case {v.nCols*i + j}: return row{i}.{components[j]};") #>
                }
            }

            set {
                CheckRowIndex(iRow);
                CheckColIndex(iCol);
                var idx = <#= v.nCols #> * iRow + iCol;
                switch (idx) {
                    default:
                    <#= GenRC((i,j) => $"case {v.nCols*i + j}: row{i}.{components[j]} = value; break;") #>
                }
            }
        }

<#
    foreach (var otherNumberType in numberTypes) {
        if (otherNumberType == v.numberType)
            continue;

        var otherVectorType = $"{otherNumberType.shortName}{v.nCols}";
        var otherMatrixType = $"{otherNumberType.shortName}{v.nRows}x{v.nCols}";
#>
        public <#=otherMatrixType#> to<#=Capitalize(otherMatrixType)#>() {
            return new <#=otherMatrixType#>(<#= genR(i => $"row{i}.to{Capitalize(otherVectorType)}()") #>);
        }
<# } #>

        public static numberMxN operator - (numberMxN a) {
            return new numberMxN(<#= genR(i => $"-a.row{i}") #>);
        }

        public static numberMxN operator + (numberMxN a, numberMxN b) {
            return new numberMxN(<#= genR(i => $"a.row{i} + b.row{i}") #>);
        }

        public static numberMxN operator - (numberMxN a, numberMxN b) {
            return new numberMxN(<#= genR(i => $"a.row{i} - b.row{i}") #>);
        }

        public static numberMxN operator * (number a, numberMxN b) {
            return new numberMxN(<#= genR(i => $"a * b.row{i}") #>);
        }

        public static numberMxN operator * (numberMxN a, number b) {
            return new numberMxN(<#= genR(i => $"a.row{i} * b") #>);
        }

        public static numberMxN operator / (numberMxN a, number b) {
            return new numberMxN(<#= genR(i => $"a.row{i} / b") #>);
        }

        public static numberM operator * (numberMxN a, numberN b) {
            return new numberM(<#= genR(i => $"Mathx.dot(a.row{i}, b)") #>);
        }

        public static numberN operator * (numberM a, numberMxN b) {
            numberN result = new numberN();
            <#= GenR(i => $"result += a.{components[i]} * b.row{i};") #>

            return result;
        }

<# 
    foreach (int nColsP in dimensions) {
        var rhsType = $"{v.numberType.shortName}{v.nCols}x{nColsP}";
        var retType = $"{v.numberType.shortName}{v.nRows}x{nColsP}";
#>
        public static <#= retType #> operator * (numberMxN a, <#= rhsType #> b) {
            var result = <#= retType #>.zero;
            for (int i = 0; i < <#= v.nRows #>; i++)
            for (int j = 0; j < <#= nColsP #>; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

<# } #>
<# if (v.nCols == v.nRows && v.nRows == 3) { #>
        public numberMxN inverse() {
            var result = new numberMxN();
            result[0, 0] =  (this[1, 1]*this[2, 2] - this[1, 2]*this[2, 1])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[0, 1] = -(this[0, 1]*this[2, 2] - this[0, 2]*this[2, 1])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[0, 2] =  (this[0, 1]*this[1, 2] - this[0, 2]*this[1, 1])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[1, 0] = -(this[1, 0]*this[2, 2] - this[1, 2]*this[2, 0])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[1, 1] =  (this[0, 0]*this[2, 2] - this[0, 2]*this[2, 0])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[1, 2] = -(this[0, 0]*this[1, 2] - this[0, 2]*this[1, 0])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[2, 0] =  (this[1, 0]*this[2, 1] - this[1, 1]*this[2, 0])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[2, 1] = -(this[0, 0]*this[2, 1] - this[0, 1]*this[2, 0])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);
            result[2, 2] =  (this[0, 0]*this[1, 1] - this[0, 1]*this[1, 0])/(this[0, 0]*this[1, 1]*this[2, 2] - this[0, 0]*this[1, 2]*this[2, 1] - this[0, 1]*this[1, 0]*this[2, 2] + this[0, 1]*this[1, 2]*this[2, 0] + this[0, 2]*this[1, 0]*this[2, 1] - this[0, 2]*this[1, 1]*this[2, 0]);

            return result;
        }

<# } #>
        public numberNxM transpose() {
            var result = new numberNxM();
            for (int i = 0; i < <#= v.nRows #>; i++)
            for (int j = 0; j < <#= v.nCols #>; j++)
                result[j, i] = this[i, j];

            return result;
        }

        private static void CheckRowIndex(int iRow) {
            if (iRow < 0 || iRow >= <#= v.nRows #>)
                throw new System.IndexOutOfRangeException("Matrix index is out of bounds");
        }

        private static void CheckColIndex(int iCol) {
            if (iCol < 0 || iCol > <#= v.nCols #>)
                throw new System.IndexOutOfRangeException("Matrix index is out of bounds");
        }
    }
}
<# }); #>
