<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".dummy" #>
<#@ include file="TemplateHelpers/T4MultipleOutputs.ttinclude" #>
<#@ include file="TemplateHelpers/T4AnonymousList.ttinclude" #>
<#@ include file="TemplateHelpers/T4GenShortcuts.ttinclude" #>
<#@ include file="TemplateHelpers/T4StringUtils.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
    var allComponents = "xyzw".Select(c => c.ToString()).ToArray();
    var dimensions = CreateList(2, 3, 4);
    var numberTypes = CreateList(
        new { shortName="float",  qualifiedName="System.Single" },
        new { shortName="double", qualifiedName="System.Double" }
    );

    var unaryFunctions = CreateList(
        "abs",
        "sqr",
        "sqrt",
        "exp",
        "log",
        "sin",
        "cos",
        "tan"
    );

    var binaryFunctions = CreateList(
        "plus",
        "minus",
        "atan2"
    );

    var variants =
        from numType in numberTypes
        from nComponents in dimensions
        select new {
            outputName  = $"{numType.shortName}{nComponents}",
            numberType  = numType,
            nComponents = nComponents,
            components  = allComponents.Take(nComponents).ToArray(),
        };

    MultipleOutputs.OutputExtension = ".cs";
    MultipleOutputs.OutputDirectory = "Src/Generated";

    MultipleOutputs.ForEachVariant(this.GenerationEnvironment,  variants, v => {

        Func<Func<int, string>, string> Geni = 
            f => GenN(v.nComponents, i => f(i));
        Func<Func<string, string>, string> Genc =
            f => Gen(v.components, c => f(c));
        Func<Func<int, string>, string> geni =
            f => GenN(v.nComponents, i => f(i), sep: ", ");
        Func<Func<string, string>, string> genc =
            f => Gen(v.components, c => f(c), sep: ", ");

#>
// This file is autogenerated. Edit VectorN.tt instead.
namespace AntilatencyMath {
    using number = <#= v.numberType.qualifiedName #>;
    using numberN = <#= v.outputName #>;
    using numberQ = <#= v.numberType.shortName #>Q;

    #if UNITY_5_3_OR_NEWER
    [System.Serializable]
    #endif
    public partial struct <#= v.outputName #> {

        public number <#= genc(c => c) #>;

        public <#= v.outputName #> (<#= genc(c => $"number {c}") #>) {
            <#= Genc(c => $"this.{c} = {c};") #>
        }

        public number this[int idx] {
            get {
                CheckIndex(idx);
                switch (idx) {
                    default:
                    <#= Geni(i => $"case {i}: return {v.components[i]};") #>
                }
            }

            set {
                CheckIndex(idx);
                switch (idx) {
                    <#= Geni(i => $"case {i}: {v.components[i]} = value; return;") #>
                }
            }
        }

        public number sqrMagnitude {
            get { return <#= Gen(v.components, c => $"{c} * {c}", sep: " + ") #>; }
        }

        public number magnitude {
            get { return (number)System.Math.Sqrt(sqrMagnitude); }
        }

        public numberN normalized {
            get { return this / magnitude; }
        }

        public void normalize() {
            var mag = magnitude;
            <#= Genc(c => $"{c} /= mag;") #>
        }

<#
    foreach (var targetNumberType in numberTypes)
    foreach (var targetVectorSize in dimensions) {
        if (targetNumberType == v.numberType && targetVectorSize == v.nComponents)
            continue;

            var targetName = targetNumberType.shortName + targetVectorSize;
            var conversionPrefix =
                (targetNumberType.shortName != v.numberType.shortName)
                    ? $"({targetNumberType.shortName})" : "";

            var targetComponents = allComponents
                .Take(targetVectorSize)
                .Select((c, i) => (i >= v.nComponents) ? "0" : $"{conversionPrefix}{c}"
            );
#>
        public <#= targetName #> to<#= Capitalize(targetName) #>() {
            return new <#= targetName #>(<#= string.Join(", ", targetComponents) #>);
        }

<# } #>
<# if (v.nComponents == 4) { #>
        public numberQ to<#= Capitalize(v.numberType.shortName) #>Q() {
            return new numberQ(x, y, z, w);
        }

<# } #>
        public number[] toArray() {
            return new number[] { <#= genc(c => c) #> };
        }

        public static readonly numberN zero =
            new numberN(<#= genc(c => "0") #>);

        public static readonly numberN ones =
            new numberN(<#= genc(c => "1") #>);

<# foreach (var comp in v.components) { #>
        public static readonly numberN pos<#= comp.ToUpper() #> =
            new numberN(<#= genc(c => c == comp ? "1" : "0") #>);

        public static readonly numberN neg<#= comp.ToUpper() #> =
            new numberN(<#= genc(c => c == comp ? "-1" : "0") #>);

<# } #>
        public static numberN operator - (numberN a) {
            return new numberN(<#= genc(c => $"-a.{c}") #>);
        }

        public static numberN operator + (numberN a, numberN b) {
            return new numberN(<#= genc(c => $"a.{c} + b.{c}") #>);
        }

        public static numberN operator - (numberN a, numberN b) {
            return new numberN(<#= genc(c => $"a.{c} - b.{c}") #>);
        }

        public static numberN operator * (number a, numberN b) {
            return new numberN(<#= genc(c => $"a * b.{c}") #>);
        }

        public static numberN operator * (numberN a, number b) {
            return new numberN(<#= genc(c => $"a.{c} * b") #>);
        }

        public static numberN operator * (numberN a, numberN b) {
            return new numberN(<#= genc(c => $"a.{c} * b.{c}") #>);
        }

        public static numberN operator / (numberN a, number b) {
            return new numberN(<#= genc(c => $"a.{c} / b") #>);
        }

        public override string ToString() {
            return <#= Gen(v.components, c => $"{c}.ToString()", sep: " + \" \" + ") #>;
        }

        private static void CheckIndex(int idx) {
            if (idx < 0 || idx >= <#= v.nComponents #>)
                throw new System.IndexOutOfRangeException();
        }
    }

    public static partial class Mathx {

        public static numberN lerp(numberN a, numberN b, number t) {
            return (1 - t) * a + t * b;
        }

        public static number dot(numberN a, numberN b) {
            return <#= Gen(v.components, c => $"a.{c} * b.{c}", sep: " + ") #>;
        }

<# if (v.nComponents == 3) { #>
        public static numberN cross(numberN a, numberN b) {
            return new numberN(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);
        }

        public static <#= v.numberType.shortName + "3x3" #> crossMatrix(numberN v) {
            return new <#= v.numberType.shortName + "3x3" #>(
                0,   -v.z,  v.y,
                v.z,    0, -v.x,
               -v.y,  v.x,    0
            );
        }

        public static numberN perpendicular(numberN v) {

            numberN vAbs = abs(v);

            number minComponentAbs = vAbs.x;
            numberN w = numberN.posX;

            if (vAbs.y < minComponentAbs) {
                minComponentAbs = vAbs.y;
                w = numberN.posY;
            }
            
            if (vAbs.z < minComponentAbs) {
                w = numberN.posZ;
            }

            return cross(v, w).normalized;
        }

<# } #>
<#
    foreach (var rhsN in dimensions) {
        var rhsName = $"{v.numberType.shortName}{rhsN}";
        var retName = $"{v.numberType.shortName}{v.nComponents}x{rhsN}";
#>
        public static <#=retName#> outer(numberN a, <#=rhsName#> b) {
            return new <#= retName #>(
                <#= Gen(v.components, c => GenN(rhsN, ir => $"a.{c} * b.{allComponents[ir]}", sep: ", ") + ",").TrimEnd(',') #>
            );
        }
<# } #>
<# foreach (var f in unaryFunctions) { #>
        public static numberN <#= f #>(numberN v) {
            var result = new numberN();
            <#= Gen(v.components, c => $"result.{c} = {f}(v.{c});") #>

            return result;
        }

<# } #>
<# foreach (var f in binaryFunctions) { #>
        public static numberN <#= f #>(numberN a, numberN b) {
            var result = new numberN();
            <#= Gen(v.components, c => $"result.{c} = {f}(a.{c}, b.{c});") #>

            return result;
        }

<# } #>

    }
}
<# }); #>
