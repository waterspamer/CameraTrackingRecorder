// This file is autogenerated. Edit MatrixMxN.tt instead.
namespace AntilatencyMath {
    using number = System.Double;
    using numberM = double3;
    using numberN = double2;
    using numberD = double2;
    using numberMxN = double3x2;
    using numberNxM = double2x3;

#if UNITY_5_3_OR_NEWER
    [System.Serializable]
#endif
    public partial struct double3x2 {

        public numberN row0, row1, row2;

        public double3x2(
                number val00,
                number val01,
                number val10,
                number val11,
                number val20,
                number val21) {

            row0.x = val00;
            row0.y = val01;
            row1.x = val10;
            row1.y = val11;
            row2.x = val20;
            row2.y = val21;
        }

        private double3x2(number val) {
            row0.x = val;
            row0.y = val;
            row1.x = val;
            row1.y = val;
            row2.x = val;
            row2.y = val;
        }

        public double3x2(numberN row0, numberN row1, numberN row2) {
            this.row0 = row0;
            this.row1 = row1;
            this.row2 = row2;
        }

        public static numberMxN withRows(numberN row0, numberN row1, numberN row2) {
            return new numberMxN(row0, row1, row2);
        }

        public static numberMxN withCols(numberM col0, numberM col1) {
            return new numberMxN(
                col0.x,
                col1.x,
                col0.y,
                col1.y,
                col0.z,
                col1.z
            );
        }

        public static numberMxN diagonal(numberD v) {
            var result = new numberMxN();
            result.row0.x = v.x;
            result.row1.y = v.y;
        
            return result;
        }

        public static numberMxN diagonal(number v) {
            var result = new numberMxN();
            result.row0.x = v;
            result.row1.y = v;
        
            return result;
        }

        public static numberMxN filled(number val) {
            return new numberMxN(val);
        }

        public static readonly numberMxN zero = new numberMxN();

        public static readonly numberMxN ones = numberMxN.filled(1);

        public static readonly numberMxN identity = numberMxN.diagonal(1);

        public numberN row(int iRow) {
            CheckRowIndex(iRow);
            switch (iRow) {
                default:
                case 0: return row0;
                case 1: return row1;
                case 2: return row2;
            }
        }

        public numberM col(int iCol) {
            CheckColIndex(iCol);
            switch (iCol) {
                default:
                case 0: return new numberM(row0.x, row1.x, row2.x);
                case 1: return new numberM(row0.y, row1.y, row2.y);
            }
        }

        public void setRow(int iRow, numberN v) {
            CheckRowIndex(iRow);
            switch (iRow) {
                case 0: row0 = v; return;
                case 1: row1 = v; return;
                case 2: row2 = v; return;
            }
        }

        public void setCol(int iCol, numberM v) {
            CheckColIndex(iCol);
            switch (iCol) {
                case 0: row0.x = v.x;
                row1.x = v.y;
                row2.x = v.z; break;
                case 1: row0.y = v.x;
                row1.y = v.y;
                row2.y = v.z; break;
            }
        }

        public number this[int iRow, int iCol] { 
            get {
                CheckRowIndex(iRow);
                CheckColIndex(iCol);
                var idx = 2 * iRow + iCol;
                switch (idx) {
                    default:
                    case 0: return row0.x;
                    case 1: return row0.y;
                    case 2: return row1.x;
                    case 3: return row1.y;
                    case 4: return row2.x;
                    case 5: return row2.y;
                }
            }

            set {
                CheckRowIndex(iRow);
                CheckColIndex(iCol);
                var idx = 2 * iRow + iCol;
                switch (idx) {
                    default:
                    case 0: row0.x = value; break;
                    case 1: row0.y = value; break;
                    case 2: row1.x = value; break;
                    case 3: row1.y = value; break;
                    case 4: row2.x = value; break;
                    case 5: row2.y = value; break;
                }
            }
        }

        public float3x2 toFloat3x2() {
            return new float3x2(row0.toFloat2(), row1.toFloat2(), row2.toFloat2());
        }

        public static numberMxN operator - (numberMxN a) {
            return new numberMxN(-a.row0, -a.row1, -a.row2);
        }

        public static numberMxN operator + (numberMxN a, numberMxN b) {
            return new numberMxN(a.row0 + b.row0, a.row1 + b.row1, a.row2 + b.row2);
        }

        public static numberMxN operator - (numberMxN a, numberMxN b) {
            return new numberMxN(a.row0 - b.row0, a.row1 - b.row1, a.row2 - b.row2);
        }

        public static numberMxN operator * (number a, numberMxN b) {
            return new numberMxN(a * b.row0, a * b.row1, a * b.row2);
        }

        public static numberMxN operator * (numberMxN a, number b) {
            return new numberMxN(a.row0 * b, a.row1 * b, a.row2 * b);
        }

        public static numberMxN operator / (numberMxN a, number b) {
            return new numberMxN(a.row0 / b, a.row1 / b, a.row2 / b);
        }

        public static numberM operator * (numberMxN a, numberN b) {
            return new numberM(Mathx.dot(a.row0, b), Mathx.dot(a.row1, b), Mathx.dot(a.row2, b));
        }

        public static numberN operator * (numberM a, numberMxN b) {
            numberN result = new numberN();
            result += a.x * b.row0;
            result += a.y * b.row1;
            result += a.z * b.row2;

            return result;
        }

        public static double3x2 operator * (numberMxN a, double2x2 b) {
            var result = double3x2.zero;
            for (int i = 0; i < 3; i++)
            for (int j = 0; j < 2; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

        public static double3x3 operator * (numberMxN a, double2x3 b) {
            var result = double3x3.zero;
            for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

        public static double3x4 operator * (numberMxN a, double2x4 b) {
            var result = double3x4.zero;
            for (int i = 0; i < 3; i++)
            for (int j = 0; j < 4; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

        public numberNxM transpose() {
            var result = new numberNxM();
            for (int i = 0; i < 3; i++)
            for (int j = 0; j < 2; j++)
                result[j, i] = this[i, j];

            return result;
        }

        private static void CheckRowIndex(int iRow) {
            if (iRow < 0 || iRow >= 3)
                throw new System.IndexOutOfRangeException("Matrix index is out of bounds");
        }

        private static void CheckColIndex(int iCol) {
            if (iCol < 0 || iCol > 2)
                throw new System.IndexOutOfRangeException("Matrix index is out of bounds");
        }
    }
}
