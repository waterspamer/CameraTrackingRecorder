// This file is autogenerated. Edit MatrixMxN.tt instead.
namespace AntilatencyMath {
    using number = System.Double;
    using numberM = double2;
    using numberN = double4;
    using numberD = double2;
    using numberMxN = double2x4;
    using numberNxM = double4x2;

#if UNITY_5_3_OR_NEWER
    [System.Serializable]
#endif
    public partial struct double2x4 {

        public numberN row0, row1;

        public double2x4(
                number val00,
                number val01,
                number val02,
                number val03,
                number val10,
                number val11,
                number val12,
                number val13) {

            row0.x = val00;
            row0.y = val01;
            row0.z = val02;
            row0.w = val03;
            row1.x = val10;
            row1.y = val11;
            row1.z = val12;
            row1.w = val13;
        }

        private double2x4(number val) {
            row0.x = val;
            row0.y = val;
            row0.z = val;
            row0.w = val;
            row1.x = val;
            row1.y = val;
            row1.z = val;
            row1.w = val;
        }

        public double2x4(numberN row0, numberN row1) {
            this.row0 = row0;
            this.row1 = row1;
        }

        public static numberMxN withRows(numberN row0, numberN row1) {
            return new numberMxN(row0, row1);
        }

        public static numberMxN withCols(numberM col0, numberM col1, numberM col2, numberM col3) {
            return new numberMxN(
                col0.x,
                col1.x,
                col2.x,
                col3.x,
                col0.y,
                col1.y,
                col2.y,
                col3.y
            );
        }

        public static numberMxN diagonal(numberD v) {
            var result = new numberMxN();
            result.row0.x = v.x;
            result.row1.y = v.y;
        
            return result;
        }

        public static numberMxN diagonal(number v) {
            var result = new numberMxN();
            result.row0.x = v;
            result.row1.y = v;
        
            return result;
        }

        public static numberMxN filled(number val) {
            return new numberMxN(val);
        }

        public static readonly numberMxN zero = new numberMxN();

        public static readonly numberMxN ones = numberMxN.filled(1);

        public static readonly numberMxN identity = numberMxN.diagonal(1);

        public numberN row(int iRow) {
            CheckRowIndex(iRow);
            switch (iRow) {
                default:
                case 0: return row0;
                case 1: return row1;
            }
        }

        public numberM col(int iCol) {
            CheckColIndex(iCol);
            switch (iCol) {
                default:
                case 0: return new numberM(row0.x, row1.x);
                case 1: return new numberM(row0.y, row1.y);
                case 2: return new numberM(row0.z, row1.z);
                case 3: return new numberM(row0.w, row1.w);
            }
        }

        public void setRow(int iRow, numberN v) {
            CheckRowIndex(iRow);
            switch (iRow) {
                case 0: row0 = v; return;
                case 1: row1 = v; return;
            }
        }

        public void setCol(int iCol, numberM v) {
            CheckColIndex(iCol);
            switch (iCol) {
                case 0: row0.x = v.x;
                row1.x = v.y; break;
                case 1: row0.y = v.x;
                row1.y = v.y; break;
                case 2: row0.z = v.x;
                row1.z = v.y; break;
                case 3: row0.w = v.x;
                row1.w = v.y; break;
            }
        }

        public number this[int iRow, int iCol] { 
            get {
                CheckRowIndex(iRow);
                CheckColIndex(iCol);
                var idx = 4 * iRow + iCol;
                switch (idx) {
                    default:
                    case 0: return row0.x;
                    case 1: return row0.y;
                    case 2: return row0.z;
                    case 3: return row0.w;
                    case 4: return row1.x;
                    case 5: return row1.y;
                    case 6: return row1.z;
                    case 7: return row1.w;
                }
            }

            set {
                CheckRowIndex(iRow);
                CheckColIndex(iCol);
                var idx = 4 * iRow + iCol;
                switch (idx) {
                    default:
                    case 0: row0.x = value; break;
                    case 1: row0.y = value; break;
                    case 2: row0.z = value; break;
                    case 3: row0.w = value; break;
                    case 4: row1.x = value; break;
                    case 5: row1.y = value; break;
                    case 6: row1.z = value; break;
                    case 7: row1.w = value; break;
                }
            }
        }

        public float2x4 toFloat2x4() {
            return new float2x4(row0.toFloat4(), row1.toFloat4());
        }

        public static numberMxN operator - (numberMxN a) {
            return new numberMxN(-a.row0, -a.row1);
        }

        public static numberMxN operator + (numberMxN a, numberMxN b) {
            return new numberMxN(a.row0 + b.row0, a.row1 + b.row1);
        }

        public static numberMxN operator - (numberMxN a, numberMxN b) {
            return new numberMxN(a.row0 - b.row0, a.row1 - b.row1);
        }

        public static numberMxN operator * (number a, numberMxN b) {
            return new numberMxN(a * b.row0, a * b.row1);
        }

        public static numberMxN operator * (numberMxN a, number b) {
            return new numberMxN(a.row0 * b, a.row1 * b);
        }

        public static numberMxN operator / (numberMxN a, number b) {
            return new numberMxN(a.row0 / b, a.row1 / b);
        }

        public static numberM operator * (numberMxN a, numberN b) {
            return new numberM(Mathx.dot(a.row0, b), Mathx.dot(a.row1, b));
        }

        public static numberN operator * (numberM a, numberMxN b) {
            numberN result = new numberN();
            result += a.x * b.row0;
            result += a.y * b.row1;

            return result;
        }

        public static double2x2 operator * (numberMxN a, double4x2 b) {
            var result = double2x2.zero;
            for (int i = 0; i < 2; i++)
            for (int j = 0; j < 2; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

        public static double2x3 operator * (numberMxN a, double4x3 b) {
            var result = double2x3.zero;
            for (int i = 0; i < 2; i++)
            for (int j = 0; j < 3; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

        public static double2x4 operator * (numberMxN a, double4x4 b) {
            var result = double2x4.zero;
            for (int i = 0; i < 2; i++)
            for (int j = 0; j < 4; j++)
                result[i, j] = Mathx.dot(a.row(i), b.col(j));

            return result;
        }

        public numberNxM transpose() {
            var result = new numberNxM();
            for (int i = 0; i < 2; i++)
            for (int j = 0; j < 4; j++)
                result[j, i] = this[i, j];

            return result;
        }

        private static void CheckRowIndex(int iRow) {
            if (iRow < 0 || iRow >= 2)
                throw new System.IndexOutOfRangeException("Matrix index is out of bounds");
        }

        private static void CheckColIndex(int iCol) {
            if (iCol < 0 || iCol > 4)
                throw new System.IndexOutOfRangeException("Matrix index is out of bounds");
        }
    }
}
